#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# CETOmega_RingdownStats.py - Model comparison for ringdown (QNM) datasets
# Author: Dr. Christian Balfagon (UBA) - helper script generated by assistant
# License: MIT
#
# Purpose
# -------
# Compare three hypotheses on black-hole ringdown data:
#   H0: GR (no shift, no echoes)
#   H1: GR + echoes (adds amplitude 'a_echo' and delay 'tau_echo')
#   H2: CETOmega (frequency shift from kernel JSON; no echoes)
#
# Computes: log-likelihood (Gaussian errors), AIC, BIC, and Bayes factors (via BIC approx).
# Supports bootstrap CI for model selection.
#
# Inputs
# ------
#   --data CSV with columns:
#       event_id, f_obs, sigma_f, q_obs, sigma_q
#     (Use whichever columns are available; missing ones are ignored.)
#
#   --cet-json kernel JSON (N-pole Stieltjes) used to compute fractional shift d = |dω/ω|
#     If you already have per-event predicted shifts, you can pass --cet-delta-csv instead:
#       event_id, frac_shift  (use absolute or signed; signed used if column 'signed' present)
#
# Usage
# -----
# python CETOmega_RingdownStats.py --data ringdown.csv --cet-json kernel_evolved.json --out report.json
#
# Notes
# -----
# - This script does a simple, transparent treatment. For full analyses, plug into your existing QNM fitters.
# - Echo model is schematic (2 params) for model-complexity penalization; it doesn't generate waveforms.
# - Frequencies are assumed independent across events for the product likelihood (common in catalog-level tests).
#
import json, csv, argparse, math, sys, random
from typing import List, Dict, Any, Tuple, Optional
import numpy as np

def read_ringdown_csv(path: str) -> List[Dict[str, Any]]:
    rows = []
    with open(path, "r", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            def to_float(x):
                try:
                    return float(x)
                except Exception:
                    return None
            rows.append({
                "event_id": row.get("event_id",""),
                "f_obs": to_float(row.get("f_obs","")),
                "sigma_f": to_float(row.get("sigma_f","")),
                "q_obs": to_float(row.get("q_obs","")),
                "sigma_q": to_float(row.get("sigma_q","")),
            })
    return rows

def read_kernel_json_delta(path: str) -> float:
    """Compute a single CET fractional shift dω/ω from kernel JSON if present.
       Otherwise return a conservative default 1e-4.
    """
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        evo = (data.get("evolution") or {}).get("targets") or {}
        if "frac_shift" in evo:
            return float(evo["frac_shift"])
    except Exception:
        pass
    return 1e-4

def read_cet_delta_csv(path: str) -> Dict[str, float]:
    out = {}
    with open(path, "r", encoding="utf-8") as f:
        r = csv.DictReader(f)
        for row in r:
            k = row.get("event_id","")
            if not k:
                continue
            if "signed" in row and row["signed"] not in (None, ""):
                try:
                    out[k] = float(row["signed"])
                except Exception:
                    continue
            else:
                try:
                    out[k] = float(row.get("frac_shift",""))
                except Exception:
                    continue
    return out

def loglike_gauss(obs: List[Tuple[Optional[float],Optional[float]]], preds: List[Optional[float]]) -> float:
    ll = 0.0
    for (y, s), yhat in zip(obs, preds):
        if y is None or s is None or yhat is None:
            continue
        if s <= 0:
            continue
        resid = (y - yhat) / s
        ll += -0.5 * (resid*resid + math.log(2*math.pi*s*s))
    return ll

def model_scores(data: List[Dict[str,Any]], cet_shift: float, per_event_shift: Dict[str,float], k_params: Dict[str,int]) -> Dict[str, Any]:
    n_eff = 0
    y = []
    s = []
    ids = []
    for row in data:
        if row["f_obs"] is None or row["sigma_f"] is None:
            continue
        ids.append(row["event_id"])
        # Observed fractional shift w.r.t GR baseline -> 0 with sigma_f/f_obs as uncertainty proxy
        y.append(0.0)
        s.append(row["sigma_f"] / max(1e-30, row["f_obs"]))
        n_eff += 1
    if n_eff == 0:
        raise ValueError("No usable frequency rows (f_obs, sigma_f).")

    preds = {}
    preds["GR"] = [0.0 for _ in range(n_eff)]
    preds["GR+echoes"] = [0.0 for _ in range(n_eff)]
    p = []
    for ev in ids:
        if per_event_shift and ev in per_event_shift:
            p.append(per_event_shift[ev])
        else:
            p.append(cet_shift)
    preds["CETOmega"] = p

    obs_pairs = list(zip(y, s))
    ll = {name: loglike_gauss(obs_pairs, preds[name]) for name in preds.keys()}

    kH = {
        "GR": k_params.get("GR", 0),
        "GR+echoes": k_params.get("GR+echoes", 2),
        "CETOmega": k_params.get("CETOmega", 0)
    }
    aic = {name: -2*ll[name] + 2*kH[name] for name in ll}
    bic = {name: -2*ll[name] + kH[name]*math.log(n_eff) for name in ll}

    def bayes_factor(ref: str, alt: str) -> float:
        d = bic[alt] - bic[ref]
        lnB = -0.5 * d
        try:
            return float(math.exp(lnB))
        except OverflowError:
            return float("inf") if lnB>0 else 0.0

    BF = {
        "CETOmega_vs_GR": bayes_factor("GR", "CETOmega"),
        "CETOmega_vs_GR+echoes": bayes_factor("GR+echoes", "CETOmega"),
        "GR_vs_GR+echoes": bayes_factor("GR+echoes", "GR"),
    }

    return {
        "n_events": n_eff,
        "loglike": ll,
        "AIC": aic,
        "BIC": bic,
        "BayesFactor": BF,
        "ids": ids
    }

def bootstrap_selection(data: List[Dict[str,Any]], cet_shift: float, per_event_shift: Dict[str,float], k_params: Dict[str,int], B: int = 200, seed: int = 123) -> Dict[str, Any]:
    rng = random.Random(seed)
    models = ["GR","GR+echoes","CETOmega"]
    counts = {m: 0 for m in models}
    for _ in range(B):
        sample = [rng.choice(data) for _ in data]
        res = model_scores(sample, cet_shift, per_event_shift, k_params)
        bic = res["BIC"]
        winner = min(bic.items(), key=lambda kv: kv[1])[0]
        counts[winner] += 1
    return {"bootstrap_winner_counts": counts, "B": B}

def main():
    ap = argparse.ArgumentParser(description="CETOmega ringdown model comparison (BIC/AIC/Bayes factors)")
    ap.add_argument("--data", required=True, help="CSV: event_id,f_obs,sigma_f[,q_obs,sigma_q]")
    g = ap.add_mutually_exclusive_group(required=False)
    g.add_argument("--cet-json", help="Kernel JSON to infer default CET fractional shift")
    g.add_argument("--cet-delta", type=float, help="Fixed CET fractional shift (e.g., 1e-4)")
    ap.add_argument("--cet-delta-csv", help="CSV with per-event shifts: event_id,frac_shift or event_id,signed")
    ap.add_argument("--out", required=True, help="Output JSON report")
    ap.add_argument("--boots", type=int, default=0, help="Bootstrap repetitions (0 disables)")
    ap.add_argument("--seed", type=int, default=123, help="Bootstrap RNG seed")
    ap.add_argument("--kCET", type=int, default=0, help="Free params count for CET (default 0; kernel fixed)")
    ap.add_argument("--kGR", type=int, default=0, help="Free params count for GR (default 0)")
    ap.add_argument("--kECHO", type=int, default=2, help="Free params count for GR+echoes (default 2)")
    args = ap.parse_args()

    data = read_ringdown_csv(args.data)

    if args.cet_delta is not None:
        cet_shift = float(args.cet_delta)
    elif args.cet_json:
        cet_shift = read_kernel_json_delta(args.cet_json)
    else:
        cet_shift = 1e-4

    per_event = {}
    if args.cet_delta_csv:
        per_event = read_cet_delta_csv(args.cet_delta_csv)

    k_params = {"CETOmega": args.kCET, "GR": args.kGR, "GR+echoes": args.kECHO}
    scores = model_scores(data, cet_shift, per_event, k_params)

    report = {"input": {
                "data": args.data,
                "cet_json": args.cet_json,
                "cet_delta": cet_shift,
                "cet_delta_csv": args.cet_delta_csv,
                "k_params": k_params
              }}
    report.update(scores)

    if args.boots and args.boots > 0:
        boot = bootstrap_selection(data, cet_shift, per_event, k_params, B=args.boots, seed=args.seed)
        report.update(boot)

    with open(args.out, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2, ensure_ascii=False)

    print(json.dumps({"status":"ok","out":args.out}, indent=2))

if __name__ == "__main__":
    main()
