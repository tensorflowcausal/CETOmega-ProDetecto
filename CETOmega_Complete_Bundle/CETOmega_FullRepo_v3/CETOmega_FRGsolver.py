#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# CETOmega_FRGsolver.py - FRG causal solver for CET Omega
# Author: Dr. Christian Balfagon (UBA) - helper script generated by assistant
# License: MIT
#
# Description
# -----------
# Implements a positivity-preserving *replicator* flow for texonic spectral densities
# represented by an N-pole Stieltjes ansatz:
#     rho_ell(mu) = sum_j c_j(ell) delta(mu - m_j(ell)),  with c_j > 0, m_j > 0.
#
# The flow is:
#     d/dell [c_i] = c_i * ( A_i - <A> ),       with A_i = c0 - sum_k K(m_i, m_k) * c_k,
#     d/dell [m_i] = - tau * dA/dmu |_{mu=m_i},   (optional mass-drift; can be disabled)
#
# This preserves c_i >= 0 (replicator form).  The kernel K(mu,nu) is positive-definite and
# configurable; by default it is a Cauchy/Lorentz-type:
#     K(mu,nu) = alpha / ( 1 + ((mu-nu)/sigma)^2 )
#
# Inputs / Outputs
# ----------------
# - Input JSON (example):
#   {
#     "version": "vOmegaR1",
#     "units": {"m": "1/m", "omega": "Hz"},
#     "poles": [{"c": 0.3, "m": 1.2}, {"c": 0.7, "m": 3.5}],
#     "meta": { "note": "bench-compatible" }
#   }
#
# - Output JSON:
#   same structure with updated poles and an "evolution" block.
#
# CLI Example
# -----------
# python CETOmega_FRGsolver.py #     --in kernel_in.json --out kernel_evolved.json #     --steps 500 --dell 0.01 --alpha 1.0 --sigma 1.0 --c0 0.0 #     --tau 0.0 --keep-norm --export-F --wmin 0.0 --wmax 10.0 --wpts 512
#
# Notes
# -----
# - This module does NOT enforce Hankel-PSD tests directly. Run your bench afterwards.
# - Units: this solver assumes m_j are in 1/length (e.g., 1/m) and omega in 1/time.
# - The F(omega) exported is: F(omega) = omega^2 * sum_j [ c_j / (omega^2 + m_j^2) ], normalized by F(inf)=sum c_j.

import json
import argparse
import math
import sys
from typing import List, Dict, Any
import numpy as np

def _read_kernel_json(path: str) -> Dict[str, Any]:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    if "poles" not in data or not isinstance(data["poles"], list):
        raise ValueError("Input JSON missing 'poles' list.")
    poles = []
    for p in data["poles"]:
        # accept flexible keys
        c = p.get("c", p.get("cj", p.get("c_j", None)))
        m = p.get("m", p.get("mj", p.get("m_j", None)))
        if c is None or m is None:
            raise ValueError("Each pole must have 'c' and 'm' (or cj/mj, c_j/m_j).")
        poles.append({"c": float(c), "m": float(m)})
    data["poles"] = poles
    return data

def _write_kernel_json(path: str, base: Dict[str, Any], poles: List[Dict[str, float]], evo_meta: Dict[str, Any]):
    out = dict(base)  # shallow copy of meta
    out["poles"] = [{"c": float(p["c"]), "m": float(p["m"])} for p in poles]
    out.setdefault("evolution", {})
    out["evolution"] = evo_meta
    with open(path, "w", encoding="utf-8") as f:
        json.dump(out, f, indent=2, ensure_ascii=False)

def _kernel_K(mu: float, nu: float, alpha: float, sigma: float, form: str="cauchy") -> float:
    """Positive kernel K(mu,nu) used in A(mu) = c0 - integral K(mu,nu) rho(nu) dnu  (discrete sum)."""
    x = (mu - nu) / max(1e-12, sigma)
    if form == "cauchy":
        return alpha / (1.0 + x*x)
    elif form == "gauss":
        return alpha * math.exp(-0.5 * x*x)
    elif form == "laplace":
        return alpha * math.exp(-abs(x))
    else:
        # default to cauchy if unknown
        return alpha / (1.0 + x*x)

def _A_i(i: int, poles: List[Dict[str,float]], alpha: float, sigma: float, c0: float, form: str) -> float:
    mi = poles[i]["m"]
    # discrete sum_k K(m_i, m_k) c_k
    s = 0.0
    for pk in poles:
        s += _kernel_K(mi, pk["m"], alpha, sigma, form) * pk["c"]
    return c0 - s

def _A_vec(poles: List[Dict[str,float]], alpha: float, sigma: float, c0: float, form: str) -> np.ndarray:
    n = len(poles)
    A = np.zeros(n, dtype=float)
    for i in range(n):
        A[i] = _A_i(i, poles, alpha, sigma, c0, form)
    return A

def _A_prime_mu(i: int, poles: List[Dict[str,float]], alpha: float, sigma: float, c0: float, form: str) -> float:
    """d/dmu A(mu)|_{mu=m_i} = - sum_k d/dmu K(mu, m_k) c_k   (c0 has zero derivative)."""
    mi = poles[i]["m"]
    s = 0.0
    for pk in poles:
        nu = pk["m"]
        c = pk["c"]
        x = (mi - nu) / max(1e-12, sigma)
        if form == "cauchy":
            dK = - 2.0 * alpha * x / (1.0 + x*x)**2 * (1.0/max(1e-12, sigma))
        elif form == "gauss":
            dK = - alpha * x * math.exp(-0.5*x*x) * (1.0/max(1e-12, sigma))
        elif form == "laplace":
            signx = 1.0 if x > 0 else (-1.0 if x < 0 else 0.0)
            dK = - alpha * signx * math.exp(-abs(x)) * (1.0/max(1e-12, sigma))
        else:
            dK = - 2.0 * alpha * x / (1.0 + x*x)**2 * (1.0/max(1e-12, sigma))
        s += dK * c
    return -s  # because A = c0 - sum K c

def _replicator_step(poles: List[Dict[str,float]], dell: float, alpha: float, sigma: float,
                     c0: float, tau: float, keep_norm: bool, form: str, scheme: str="euler") -> List[Dict[str,float]]:
    """One integration step in ell for c_i and (optionally) m_i."""
    n = len(poles)
    c = np.array([p["c"] for p in poles], dtype=float)
    m = np.array([p["m"] for p in poles], dtype=float)
    # Compute A_i and <A>
    A = _A_vec(poles, alpha, sigma, c0, form)
    A_mean = float(np.dot(c, A) / max(1e-30, np.sum(c)))
    # dc/dell = c * (A_i - <A>)
    dc = c * (A - A_mean)
    # dm/dell = - tau * dA/dmu |_{mu=m_i}
    if tau != 0.0:
        dA_dm = np.array([_A_prime_mu(i, poles, alpha, sigma, c0, form) for i in range(n)], dtype=float)
        dm = - tau * dA_dm
    else:
        dm = np.zeros_like(m)

    if scheme.lower() == "rk4":
        # RK4 on (c,m)
        def f(cm):
            c_, m_ = cm[:n], cm[n:]
            tmp_poles = [{"c": float(c_[i]), "m": float(m_[i])} for i in range(n)]
            A_ = _A_vec(tmp_poles, alpha, sigma, c0, form)
            A_mean_ = float(np.dot(c_, A_) / max(1e-30, np.sum(c_)))
            dc_ = c_ * (A_ - A_mean_)
            if tau != 0.0:
                dA_dm_ = np.array([_A_prime_mu(i, tmp_poles, alpha, sigma, c0, form) for i in range(n)], dtype=float)
                dm_ = - tau * dA_dm_
            else:
                dm_ = np.zeros_like(m_)
            return np.concatenate([dc_, dm_])
        y = np.concatenate([c, m])
        k1 = f(y)
        k2 = f(y + 0.5*dell*k1)
        k3 = f(y + 0.5*dell*k2)
        k4 = f(y + dell*k3)
        y_next = y + (dell/6.0)*(k1 + 2*k2 + 2*k3 + k4)
        c_next, m_next = y_next[:n], y_next[n:]
    else:
        # Euler
        c_next = c + dell * dc
        m_next = m + dell * dm

    # enforce positivity and minimal floor to avoid underflow
    c_next = np.maximum(c_next, 1e-18)
    m_next = np.maximum(m_next, 1e-18)

    # optional renormalization of sum c_j
    if keep_norm:
        s = float(np.sum(c_next))
        if s > 0:
            c_next = c_next / s * float(np.sum(c))

    new_poles = [{"c": float(c_next[i]), "m": float(m_next[i])} for i in range(n)]
    return new_poles

def evolve_kernel(json_in: str, json_out: str, steps: int = 200, dell: float = 0.01,
                  alpha: float = 1.0, sigma: float = 1.0, c0: float = 0.0,
                  tau: float = 0.0, keep_norm: bool = True, form: str = "cauchy",
                  scheme: str = "rk4", export_F: bool = False, wmin: float = 0.0,
                  wmax: float = 10.0, wpts: int = 512) -> Dict[str, Any]:
    """Evolves the input kernel JSON through 'steps' in ell with step size 'dell'."""
    data = _read_kernel_json(json_in)
    poles = data["poles"]
    # quick sanity
    for p in poles:
        if p["c"] <= 0 or p["m"] <= 0:
            raise ValueError("All input poles must satisfy c>0, m>0.")
    # integrate
    for _ in range(steps):
        poles = _replicator_step(poles, dell, alpha, sigma, c0, tau, keep_norm, form, scheme)

    # export F(omega) if requested
    spectra = None
    if export_F:
        ws = np.linspace(wmin, wmax, wpts)
        # F(omega) = omega^2 * sum c_j / (omega^2 + m_j^2)
        F = ws*ws * np.sum([p["c"] / (ws*ws + (p["m"]**2)) for p in poles], axis=0)
        Finf = float(sum([p["c"] for p in poles]))
        if Finf > 0:
            Fnorm = F / Finf
        else:
            Fnorm = F
        spectra = {
            "omega": ws.tolist(),
            "F": F.tolist(),
            "F_norm": Fnorm.tolist()
        }
        # write CSV alongside JSON
        import os, csv
        base, _ = os.path.splitext(json_out)
        csv_path = base + "_Fomega.csv"
        with open(csv_path, "w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["omega", "F", "F_norm"])
            for i in range(len(ws)):
                w.writerow([float(ws[i]), float(F[i]), float(Fnorm[i])])

    evo_meta = {
        "frg": {
            "steps": steps, "dell": dell, "alpha": alpha, "sigma": sigma,
            "c0": c0, "tau": tau, "keep_norm": keep_norm, "kernel_form": form,
            "scheme": scheme
        }
    }
    if spectra is not None:
        evo_meta["spectra"] = {"csv": json_out.replace(".json","_Fomega.csv")}

    _write_kernel_json(json_out, {k:v for k,v in data.items() if k!="poles"}, poles, evo_meta)
    return {"out": json_out, "spectra": evo_meta.get("spectra")}

def _cli():
    ap = argparse.ArgumentParser(description="CET Omega - FRG causal solver for N-pole Stieltjes kernels")
    ap.add_argument("--in", dest="inp", required=True, help="Input kernel JSON")
    ap.add_argument("--out", dest="out", required=True, help="Output kernel JSON")
    ap.add_argument("--steps", type=int, default=200, help="FRG steps in ell")
    ap.add_argument("--dell", type=float, default=0.01, help="Step size in ell")
    ap.add_argument("--alpha", type=float, default=1.0, help="Kernel amplitude alpha")
    ap.add_argument("--sigma", type=float, default=1.0, help="Kernel width sigma (same units as m)")
    ap.add_argument("--c0", type=float, default=0.0, help="Offset c0 in A(mu)")
    ap.add_argument("--tau", type=float, default=0.0, help="Mass-drift coefficient tau (0 disables)")
    ap.add_argument("--keep-norm", action="store_true", help="Keep sum c_j constant")
    ap.add_argument("--form", choices=["cauchy","gauss","laplace"], default="cauchy", help="Form of K(mu,nu)")
    ap.add_argument("--scheme", choices=["euler","rk4"], default="rk4", help="Integrator")
    ap.add_argument("--export-F", action="store_true", help="Export F(omega) CSV alongside JSON")
    ap.add_argument("--wmin", type=float, default=0.0, help="Min omega for F(omega)")
    ap.add_argument("--wmax", type=float, default=10.0, help="Max omega for F(omega)")
    ap.add_argument("--wpts", type=int, default=512, help="Samples for F(omega)")
    args = ap.parse_args()

    try:
        res = evolve_kernel(
            json_in=args.inp, json_out=args.out, steps=args.steps, dell=args.dell,
            alpha=args.alpha, sigma=args.sigma, c0=args.c0, tau=args.tau,
            keep_norm=args.keep_norm, form=args.form, scheme=args.scheme,
            export_F=args.export_F, wmin=args.wmin, wmax=args.wmax, wpts=args.wpts
        )
        print(json.dumps(res, indent=2))
    except Exception as e:
        print(f"[FRGsolver ERROR] {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    _cli()
